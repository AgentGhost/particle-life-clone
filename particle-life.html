<html><head></head><body><canvas id="life" width="2000" height="2000"></canvas>
    <script>
        SIZE = 1000;
        SPAWNFREEBORDER = SIZE / 5;
        R3D = true;
        PARTICLES = [];
        create = (number, color) => {
            particle = (x, y, z, c) => {
                return { x: x, y: y, z: z, vx: 0, vy: 0, vz: 0, color: c };
            };
            random = () => {
                return Math.random() * (SIZE - 2 * SPAWNFREEBORDER) + SPAWNFREEBORDER;
            };
            group = [];
            for (let i = 0; i < number; i++) {
                group.push(particle(random(), random(), random() * R3D, color));
                PARTICLES.push(group[i]);
            }
            return group;
        };
        GRAVITATIONDISTANCE = SIZE / 4;
        COLORS = ["yellow", "red", "green", "blue", "purple", "white"];
        ENTITYNUMBER = Math.round(500 / COLORS.length);
        ENTITIES = [];
        for (i = 0; i < COLORS.length; i++) {
            ENTITIES.push(create(ENTITYNUMBER, COLORS[i]));
        };
        STRENGTHPERCENTAGE = 0.5;
        GRAVITY = [];
        for (i = 0; i < COLORS.length ** 2; i++) {
            GRAVITY.push(STRENGTHPERCENTAGE * (Math.random() * 2 - 1));
        };
        BACKGROUNDCOLOR = "black";
        ENTITYSCALE = 1;
        MINIMUMENTITYSIZEOFFSET = false;
        ENTITYDISTANCEZOOM = 2;
        LAYER = document.getElementById("life").getContext("2d");
        update = () => {
            rule = (particles1, particles2, gravity) => {
                for (let i = 0; i < particles1.length; i++) {
                    fx = fy = fz = 0;
                    for (let j = 0; j < particles2.length; j++) {
                        a = particles1[i];
                        b = particles2[j];
                        dx = a.x - b.x;
                        dy = a.y - b.y;
                        dz = (a.z - b.z) * R3D;
                        distance = Math.sqrt(dx * dx + dy * dy + dz * dz * R3D);
                        if (distance > 0 && distance < GRAVITATIONDISTANCE) {
                            F = gravity / distance;
                            fx += F * dx;
                            fy += F * dy;
                            fz += F * dz;
                        };
                    };
                    a.vx = (a.vx + fx) * 0.5;
                    a.vy = (a.vy + fy) * 0.5;
                    a.vz = (a.vz + fz) * 0.5 * R3D;
                    a.x += a.vx;
                    a.y += a.vy;
                    a.z += a.vz;
                    if (a.x <= 0 && a.vx < 0 || a.x >= SIZE && a.vx > 0) {
                        a.vx *= -1;
                    };
                    if (a.y <= 0 && a.vy < 0 || a.y >= SIZE && a.vy > 0) {
                        a.vy *= -1;
                    };
                    if (a.z <= 0 && a.vz < 0 || a.z >= SIZE && a.vz > 0) {
                        a.vz *= -1;
                    };
                };
            };
            draw = (x, y, c, s) => {
                LAYER.fillStyle = c;
                LAYER.fillRect(x, y, s, s);
            };
            for (i = 0; i < COLORS.length; i++) {
                for (j = 0; j < COLORS.length; j++) {
                    rule(ENTITIES[i], ENTITIES[j], GRAVITY[(i+1)*(j+1)-1]);
                };
            };
            draw(0, 0, BACKGROUNDCOLOR, SIZE);
            for (i = 0; i < PARTICLES.length; i++) {
                draw(PARTICLES[i].x, PARTICLES[i].y, PARTICLES[i].color, ENTITYSCALE*(MINIMUMENTITYSIZEOFFSET+ENTITYDISTANCEZOOM*PARTICLES[i].z/SIZE));
            };
            draw(SIZE, 0, "white", 2000);
            draw(0, SIZE, "white", 2000);
            requestAnimationFrame(update);
        };
        update();
    </script>
</body></html>
